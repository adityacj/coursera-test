<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <title>Module3</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/styles.css">
    <link href='https://fonts.googleapis.com/css?family=Oxygen:400,300,700' rel='stylesheet' type='text/css'>
  </head>
<body>

  <header>
    <nav id="header-nav" class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a href="index.html" class="pull-left visible-md visible-lg">
          </a>
      
      <div class="navbar-brand">
            <a href="index.html"><h1>Food, LLC</h1></a>
      </div>

       <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsable-nav" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
       </button>
       </div>

        <div id="collapsable-nav" class="collapse navbar-collapse">
           <ul id="nav-list" class="nav navbar-nav navbar-right, visible-xs">
            <li>
              <a href="#">
                <br class="hidden-xs"> Chicken</a>
            </li>
            <li>
              <a href="#">
                <br class="hidden-xs"> Beef</a>
            </li>
            <li>
              <a href="#">
                <br class="hidden-xs"> Sushi</a>
            </li>
          </ul><!-- #nav-list -->
        </div><!-- .collapse .navbar-collapse -->
        </div>
        </nav>

  </header>

  <div class = text-center>Our Menu<br><br></div>

  <div id="main-content" class="container">
  <div>
    <div>
      

      <div class="col-xs-12">
        <p><div class = "text-center">Chicken</div>A Journaling file system is a fault-resilient file system in which data integrity is ensured because updates to directories and bitmaps are constantly written to a serial log on disk before the original disk log is updated.The basic problem to solve: random-access memory and disk usually appear to the programmer as a set of named, shared, and rewritable storage cells, called cell storage. Cell storage has semantics that are actually quite hard to make all-or-nothing, because the act of storing destroys old data, thus potentially violating the golden rule of atomicity. If the all-or-nothing action happens to have exactly one output value, then writing that value into cell storage can be the mechanism of committing, and there is no problem. Instead of a model in which a store operation overwrites old data, we instead create a new, tentative version of the data, such that the tentative version remains invisible to any reader outside this all-or-nothing action until the action commits. Whenever any action proposes to write a new value into the variable, the journal storage manager appends the prospective new value to the end of the list.This can be achieved by interposing a layer between client and the cell storage called the Journal Storage System. The basic idea of journal storage is straightforward: we associate with every named variable not a single cell, but a list of cells in non-volatile storage; the values in the list represent the history of the variable. Whenever any action proposes to write a new value into the variable, the journal storage manager appends the prospective new value to the end of the list. The journal storage manager appends the prospective new value to the end of the list.<br></p>
      </div>
    </div>
    </div>


    <div>
    <div>
      
      <div class="col-xs-12">
        <p><div class = "text-center">Beef</div>A Journaling file system is a fault-resilient file system in which data integrity is ensured because updates to directories and bitmaps are constantly written to a serial log on disk before the original disk log is updated.The basic problem to solve: random-access memory and disk usually appear to the programmer as a set of named, shared, and rewritable storage cells, called cell storage. Cell storage has semantics that are actually quite hard to make all-or-nothing, because the act of storing destroys old data, thus potentially violating the golden rule of atomicity. If the all-or-nothing action happens to have exactly one output value, then writing that value into cell storage can be the mechanism of committing, and there is no problem. Instead of a model in which a store operation overwrites old data, we instead create a new, tentative version of the data, such that the tentative version remains invisible to any reader outside this all-or-nothing action until the action commits. Whenever any action proposes to write a new value into the variable, the journal storage manager appends the prospective new value to the end of the list.This can be achieved by interposing a layer between client and the cell storage called the Journal Storage System. The basic idea of journal storage is straightforward: we associate with every named variable not a single cell, but a list of cells in non-volatile storage; the values in the list represent the history of the variable. Whenever any action proposes to write a new value into the variable, the journal storage manager appends the prospective new value to the end of the list. The journal storage manager appends the prospective new value to the end of the list.<br></p>
      </div>
    </div>
    </div>

    <div>
    <div>
      
      <div class="col-xs-12">
        <p><div class = "text-center">Sushi</div>A Journaling file system is a fault-resilient file system in which data integrity is ensured because updates to directories and bitmaps are constantly written to a serial log on disk before the original disk log is updated.The basic problem to solve: random-access memory and disk usually appear to the programmer as a set of named, shared, and rewritable storage cells, called cell storage. Cell storage has semantics that are actually quite hard to make all-or-nothing, because the act of storing destroys old data, thus potentially violating the golden rule of atomicity. If the all-or-nothing action happens to have exactly one output value, then writing that value into cell storage can be the mechanism of committing, and there is no problem. Instead of a model in which a store operation overwrites old data, we instead create a new, tentative version of the data, such that the tentative version remains invisible to any reader outside this all-or-nothing action until the action commits. Whenever any action proposes to write a new value into the variable, the journal storage manager appends the prospective new value to the end of the list.This can be achieved by interposing a layer between client and the cell storage called the Journal Storage System. The basic idea of journal storage is straightforward: we associate with every named variable not a single cell, but a list of cells in non-volatile storage; the values in the list represent the history of the variable. Whenever any action proposes to write a new value into the variable, the journal storage manager appends the prospective new value to the end of the list. The journal storage manager appends the prospective new value to the end of the list.<br></p>
      </div>
    </div>
    </div>
  
  </div>
  <!-- jQuery (Bootstrap JS plugins depend on it) -->
  <script src="js/jquery-1.11.3.min.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script src="js/script.js"></script>
</body>
</html>
